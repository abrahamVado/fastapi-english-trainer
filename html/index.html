
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Voice Assistant — Reader & Conversation</title>
    <link rel="stylesheet" href="styles.css" /> 
</head>

<body>
  <div class="app">
    <header class="app-header">
      <div class="logo" aria-hidden="true"></div>
      <div class="title">Voice Assistant</div>
      <div class="status-chip" id="statusChip2" aria-live="polite">
        <span class="dot" id="statusDot2"></span>
        <span id="statusText2">Idle — choose an agent</span>
      </div>
    </header>

    <div class="app-body">
      <!-- Sticky sidebar -->
      <aside class="agent-sidebar" aria-label="Agent selector" role="tablist">
        <div class="side-title">Agents</div>
        <div class="stack">
          <button class="toolbtn" id="btnReader" role="tab" aria-selected="false">Reader</button>
          <button class="toolbtn active" id="btnConversation" role="tab" aria-selected="true">Conversation</button>
        </div>
      </aside>

      <!-- Main panel fills height -->
      <section class="panel">
        <div class="convo-card">
          <div class="chat-head">
            <div class="title" id="modeTitle">Agent: Conversation</div>
          </div>

          <!-- Scrollable middle area switches by mode -->
          <div id="readerView" hidden>
            <div class="reader-tools">
              <button class="toolbtn" id="btnLoadReaderText">Load sample</button>
              <button class="toolbtn" id="btnClearReaderText">Clear</button>
              <span style="opacity:.8">Click the mic to record; click again to stop & send. Or hold <kbd>Space</kbd>.</span>
            </div>
            <div id="readerText" class="reader-text" aria-live="polite"></div>
          </div>

          <div id="conversation" role="log" aria-live="polite" aria-relevant="additions"></div>

          <!-- Centered record button -->
          <div id="controls" class="controls">
            <button id="recordButton" class="record-btn" aria-label="Start recording" aria-pressed="false">
              <!-- Mic icon -->
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path fill="white" d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2zm-5 9a7 7 0 0 1-7-7H3a9 9 0 0 0 18 0h-2a7 7 0 0 1-7 7z"/>
              </svg>
            </button>
          </div>
        </div>
      </section>
    </div>
  </div>

<script>
  // ===== Config =====
  const backendUrl       = '/api/audio';        // POST audio -> { answer }
  const readerTextUrl    = '/api/reader-text';  // GET -> { text }
  const maxSeconds = 60;
  const mimeOptions = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/ogg'];

  // ===== State =====
  let agentMode = 'conversation';        // 'reader' | 'conversation'
  let chats = [], currentChatId = null;
  let isProcessing = false, isRecording = false, mediaRecorder, audioChunks = [];

  // ===== DOM =====
  const statusDot2 = document.getElementById('statusDot2');
  const statusText2 = document.getElementById('statusText2');
  const modeTitle = document.getElementById('modeTitle');
  const btnReader = document.getElementById('btnReader');
  const btnConversation = document.getElementById('btnConversation');

  const readerView = document.getElementById('readerView');
  const conversationView = document.getElementById('conversation');

  const readerTextEl = document.getElementById('readerText');
  const btnLoadReaderText = document.getElementById('btnLoadReaderText');
  const btnClearReaderText = document.getElementById('btnClearReaderText');

  const recordBtn = document.getElementById('recordButton');

  // ===== Icons =====
  const MIC_ICON = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path fill="white" d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2zm-5 9a7 7 0 0 1-7-7H3a9 9 0 0 0 18 0h-2a7 7 0 0 1-7 7z"/>
    </svg>`;
  const STOP_ICON = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path fill="white" d="M6 6h12v12H6z"/>
    </svg>`;

  function setRecordIcon(recording){
    recordBtn.innerHTML = recording ? STOP_ICON : MIC_ICON;
    recordBtn.setAttribute('aria-label', recording ? 'Stop and send' : 'Start recording');
    recordBtn.setAttribute('aria-pressed', String(recording));
  }

  // ===== Helpers =====
  function setStatus(kind, text){
    if (statusText2) statusText2.textContent = text;
    if (statusDot2)  statusDot2.className = 'dot' + (kind ? ` ${kind}` : '');
  }
  function pickSupportedMime(){ for (const m of mimeOptions){ if (MediaRecorder.isTypeSupported(m)) return m; } return ''; }

  // ===== Sidebar Mode switching =====
  function setActiveButton(){
    [btnReader, btnConversation].forEach(b=>{
      const is = (agentMode==='reader' ? b===btnReader : b===btnConversation);
      b.classList.toggle('active', is);
      b.setAttribute('aria-selected', String(is));
    });
  }
  function applyModeVisibility(){
    readerView.hidden = agentMode!=='reader';
    conversationView.hidden = agentMode!=='conversation';
    modeTitle.textContent = `Agent: ${agentMode[0].toUpperCase()+agentMode.slice(1)}`;
  }
  function setMode(mode){
    agentMode = mode;
    setActiveButton();
    applyModeVisibility();
    setStatus('', `Mode: ${mode}`);
  }
  btnReader.addEventListener('click', ()=> setMode('reader'));
  btnConversation.addEventListener('click', ()=> setMode('conversation'));

  // ===== Reader: pronunciation per word =====
  const IPA = {
    hello:'/həˈloʊ/', this:'/ðɪs/', is:'/ɪz/', a:'/ə/', sample:'/ˈsæm.pəl/',
    text:'/tɛkst/', to:'/tuː/', practice:'/ˈpræk.tɪs/', pronunciation:'/prəˌnʌn.siˈeɪ.ʃən/',
    schedule:'/ˈskedʒ.uːl/', comfortable:'/ˈkʌmftəbl/'
  };
  function roughPron(w){
    const v='aeiouy'; let syl=''; let chunk='';
    for (const ch of w.toLowerCase()){ chunk+=ch; if (v.includes(ch)){ syl+=chunk+'·'; chunk=''; } }
    syl+=chunk; syl=syl.replace(/·$/,''); return `/${syl || w.toLowerCase()}/`;
  }
  function tokenizeAndAnnotate(text){
    readerTextEl.innerHTML='';
    text.split(/\s+/).forEach(tok=>{
      const clean = tok.replace(/[^\w'-]/g,'');
      if(!clean){ return; }
      const container = document.createElement('div');
      container.className='wtoken';
      const w = document.createElement('div'); w.className='w'; w.textContent = tok;
      const p = document.createElement('div'); p.className='p';
      p.textContent = IPA[clean.toLowerCase()] || roughPron(clean);
      container.appendChild(w); container.appendChild(p);
      readerTextEl.appendChild(container);
    });
  }
  btnLoadReaderText?.addEventListener('click', async ()=>{
    try{
      const r = await fetch(readerTextUrl);
      if (r.ok){
        const data = await r.json();
        tokenizeAndAnnotate(data?.text || 'Hello! This is a sample text to practice pronunciation.');
      } else {
        tokenizeAndAnnotate('Hello! This is a sample text to practice pronunciation. Schedule a comfortable pace.');
      }
    }catch{
      tokenizeAndAnnotate('Hello! This is a sample text to practice pronunciation. Schedule a comfortable pace.');
    }
  });
  btnClearReaderText?.addEventListener('click', ()=> readerTextEl.innerHTML='');

  // ===== Conversation log helpers =====
  function addBubbleToDOM(m){
    const conversationEl = conversationView;
    const msg = document.createElement('div'); msg.className = `message ${m.role}`;
    const avatar = document.createElement('div'); avatar.className = `avatar ${m.role}`;
    avatar.innerHTML = m.role === 'user'
      ? '<svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>'
      : '<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-12.5c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5zm0 7.5c-2.21 0-4 1.79-4 4h8c0-2.21-1.79-4-4-4z"/></svg>';
    const bubble = document.createElement('div'); bubble.className = `bubble ${m.role}`;

    const content = document.createElement('div'); content.className='content';
    if (m.type === 'text') content.textContent = m.payload;
    else if (m.type === 'audio'){
      const url = URL.createObjectURL(m.payload);
      const audio = document.createElement('audio'); audio.controls = true; audio.src = url;
      content.appendChild(audio);
    }
    bubble.appendChild(content);

    const footer = document.createElement('div'); footer.className='footer';
    const divider = document.createElement('div'); divider.className='divider';
    bubble.appendChild(divider);

    const time = document.createElement('span');
    time.textContent = new Date(m.ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    footer.appendChild(time);

    bubble.prepend(footer);
    msg.appendChild(avatar); msg.appendChild(bubble);
    conversationEl.appendChild(msg);
    conversationEl.scrollTop = conversationEl.scrollHeight;
  }
  function addMessage(role,type,payload){
    const chat = chats.find(c=>c.id===currentChatId); if (!chat) return;
    const msg = { role, type, payload, ts: Date.now() };
    chat.messages.push(msg);
    addBubbleToDOM(msg);
  }
  function renderConversation(){
    conversationView.innerHTML=''; const chat = chats.find(c=>c.id===currentChatId); if (!chat) return;
    chat.messages.forEach(m => addBubbleToDOM(m));
    conversationView.scrollTop = conversationView.scrollHeight;
  }

  // ===== Recording (click toggles; Space push-to-talk) =====
  function updateRecordButtonUI(){ setRecordIcon(isRecording); }
  async function startRecording(){
    if (isProcessing || isRecording) return;
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      const mimeType = pickSupportedMime();
      mediaRecorder = new MediaRecorder(stream, mimeType ? {mimeType} : undefined);
      audioChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data.size) audioChunks.push(e.data); };
      mediaRecorder.onstop = handleStop;
      mediaRecorder.start(); isRecording = true;
      updateRecordButtonUI();
      setStatus('warn', 'Recording… click stop to send');
      setTimeout(()=>{ if (isRecording) stopRecording(); }, maxSeconds*1000);
    }catch(err){ console.error(err); setStatus('err','Mic access denied'); }
  }
  function stopRecording(auto=false){
    if (!isRecording) return; isRecording = false;
    if (auto === 'cancel'){ audioChunks = []; updateRecordButtonUI(); setStatus('','Canceled'); return; }
    mediaRecorder?.stop();
    updateRecordButtonUI();
    setStatus('warn','Sending… please wait'); isProcessing = true;
  }
  function handleStop(){
    const blob = new Blob(audioChunks, { type: mediaRecorder?.mimeType || 'audio/webm' });
    if (!blob.size){ isProcessing=false; setStatus('','Idle'); return; }
    addMessage('user','audio',blob);
    sendAudio(blob);
  }
  async function sendAudio(blob){
    const form = new FormData();
    form.append('file', blob, 'message.webm');
    form.append('mode', agentMode); // tell backend which agent
    try{
      const resp = await fetch(backendUrl, { method:'POST', body: form });
      const data = await resp.json().catch(()=> ({}));
      addMessage('bot','text', data?.answer || 'Received response.');
      setStatus('', 'Idle — ready');
    }catch(err){
      console.error(err);
      addMessage('bot','text','Error: failed to send or receive. Try again.');
      setStatus('err','Network error');
    }finally{
      isProcessing = false;
    }
  }

  // Click toggles record/stop
  recordBtn.addEventListener('click', ()=>{
    if (isRecording) stopRecording(); else startRecording();
  });

  // Keyboard (Space push-to-talk) works in both modes
  document.addEventListener('keydown', (e)=>{
    if (isProcessing) return;
    if (e.code === 'Space' && !e.repeat){
      e.preventDefault();
      if (!isRecording) startRecording();
    }
    if (e.code === 'Escape'){ e.preventDefault(); if (isRecording) stopRecording('cancel'); }
  });
  document.addEventListener('keyup', (e)=>{
    if (e.code === 'Space'){
      e.preventDefault();
      if (isRecording) stopRecording();
    }
  });

  // ===== Seed demo conversation =====
  function seedDemoChats(){
    const now = Date.now(), min = (n)=> now - n*60*1000;
    const demo = [{
      title:'Conversation demo', createdAt:min(40),
      messages:[
        { role:'user', type:'text', payload:'What’s a friendly way to start small talk at a meetup?', ts:min(39) },
        { role:'bot',  type:'text', payload:'Try: “What brought you here today?” Then follow with a related experience.', ts:min(38) },
      ]
    }];
    chats = demo.map(raw => ({
      id: Math.random().toString(36).slice(2),
      title: raw.title, createdAt: raw.createdAt,
      messages: raw.messages
    }));
    currentChatId = chats[0].id;
    renderConversation();
  }

  // ===== Init =====
  seedDemoChats();
  setMode('conversation');
  setStatus('', 'Idle — choose an agent or click the mic');
  setRecordIcon(false);
</script>
</body>
</html>
